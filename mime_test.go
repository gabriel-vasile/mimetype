package mimetype

import (
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"testing"

	"github.com/gabriel-vasile/mimetype/internal/matchers"
)

const testDataDir = "testdata"

var files = map[string]*node{
	// archives
	"pdf.pdf":     pdf,
	"zip.zip":     zip,
	"tar.tar":     tar,
	"xls.xls":     xls,
	"xlsx.xlsx":   xlsx,
	"doc.doc":     doc,
	"doc.1.doc":   doc,
	"docx.docx":   docx,
	"docx.1.docx": docx,
	"ppt.ppt":     ppt,
	"pptx.pptx":   pptx,
	"odt.odt":     odt,
	"ott.ott":     ott,
	"ods.ods":     ods,
	"ots.ots":     ots,
	"odp.odp":     odp,
	"otp.otp":     otp,
	"odg.odg":     odg,
	"otg.otg":     otg,
	"odf.odf":     odf,
	"epub.epub":   epub,
	"7z.7z":       sevenZ,
	"jar.jar":     jar,
	"gz.gz":       gzip,
	"fits.fits":   fits,
	"xar.xar":     xar,
	"bz2.bz2":     bz2,
	"a.a":         ar,
	"deb.deb":     deb,
	"rar.rar":     rar,
	"djvu.djvu":   djvu,
	"mobi.mobi":   mobi,
	"lit.lit":     lit,

	// images
	"png.png":   png,
	"jpg.jpg":   jpg,
	"psd.psd":   psd,
	"webp.webp": webp,
	"tif.tif":   tiff,
	"ico.ico":   ico,
	"bmp.bmp":   bmp,
	"bpg.bpg":   bpg,

	// video
	"mp4.mp4":   mp4,
	"mp4.1.mp4": mp4,
	"webm.webm": webM,
	"3gp.3gp":   threeGP,
	"3g2.3g2":   threeG2,
	"flv.flv":   flv,
	"avi.avi":   avi,
	"mov.mov":   quickTime,
	"mqv.mqv":   mqv,
	"mpeg.mpeg": mpeg,
	"mkv.mkv":   mkv,
	"asf.asf":   asf,

	// audio
	"mp3.mp3":   mp3,
	"wav.wav":   wav,
	"flac.flac": flac,
	"midi.midi": midi,
	"ape.ape":   ape,
	"aiff.aiff": aiff,
	"au.au":     au,
	"ogg.ogg":   ogg,
	"amr.amr":   amr,
	"mpc.mpc":   musePack,
	"m4a.m4a":   m4a,
	"m4b.m4b":   aMp4,

	// source code
	"html.html":         html,
	"svg.svg":           svg,
	"svg.1.svg":         svg,
	"txt.txt":           txt,
	"php.php":           php,
	"ps.ps":             ps,
	"json.json":         json,
	"geojson.geojson":   geoJson,
	"geojson.1.geojson": geoJson,
	"csv.csv":           csv,
	"tsv.tsv":           tsv,
	"rtf.rtf":           rtf,
	"js.js":             js,
	"lua.lua":           lua,
	"pl.pl":             perl,
	"py.py":             python,
	"tcl.tcl":           tcl,
	"vCard.vCard":       vCard,

	// binary
	"class.class": class,
	"swf.swf":     swf,
	"crx.crx":     crx,
	"wasm.wasm":   wasm,
	"exe.exe":     exe,
	"ln":          elfExe,
	"so.so":       elfLib,
	"o.o":         elfObj,
	"dcm.dcm":     dcm,

	// fonts
	"woff.woff":   woff,
	"woff2.woff2": woff2,

	// XML and subtypes of XML
	"xml.xml": xml,
	"kml.kml": kml,
	"dae.dae": collada,
	"gml.gml": gml,
	"gpx.gpx": gpx,
	"tcx.tcx": tcx,
	"x3d.x3d": x3d,

	"shp.shp": shp,
	"shx.shx": shx,
	"dbf.dbf": dbf,
	// "dbf_broken.dbf": dbf, two-bytes-length file makes Dbf matcher crash

	"sqlite3.sqlite3": sqlite3,
	"dwg.dwg":         dwg,
	"dwg.1.dwg":       dwg,
}

func TestBrokenDbf(t *testing.T) {
	errStr := "File: %s; Mime: %s != DetectedMime: %s; err: %v"
	fName := "dbf_broken.dbf" // two-bytes-length file with contents: 0x01 0xA9
	fileName := filepath.Join(testDataDir, fName)
	if dMime, _, err := DetectFile(fileName); dMime != "application/octet-stream" {
		t.Errorf(errStr, fName, "application/octet-stream", dMime, err)
	}
}

func TestMatching(t *testing.T) {
	errStr := "File: %s; Mime: %s != DetectedMime: %s; err: %v"
	for fName, node := range files {
		fileName := filepath.Join(testDataDir, fName)
		f, err := os.Open(fileName)
		if err != nil {
			t.Fatal(err)
		}
		data, err := ioutil.ReadAll(f)
		if err != nil {
			t.Fatal(err)
		}

		if dMime, _ := Detect(data); dMime != node.mime {
			t.Errorf(errStr, fName, node.mime, dMime, nil)
		}

		if _, err := f.Seek(0, io.SeekStart); err != nil {
			t.Errorf(errStr, fName, node.mime, root.mime, err)
		}

		if dMime, _, err := DetectReader(f); dMime != node.mime {
			t.Errorf(errStr, fName, node.mime, dMime, err)
		}
		f.Close()

		if dMime, _, err := DetectFile(fileName); dMime != node.mime {
			t.Errorf(errStr, fName, node.mime, dMime, err)
		}
	}
}

func TestFaultyInput(t *testing.T) {
	inexistent := "inexistent.file"
	if _, _, err := DetectFile(inexistent); err == nil {
		t.Errorf("%s should not match successfully", inexistent)
	}

	f, _ := os.Open(inexistent)
	if _, _, err := DetectReader(f); err == nil {
		t.Errorf("%s reader should not match successfully", inexistent)
	}
}

func TestEmptyInput(t *testing.T) {
	if m, _ := Detect([]byte{}); m != "inode/x-empty" {
		t.Errorf("failed to detect empty file")
	}
}

func TestGenerateSupportedMimesFile(t *testing.T) {
	f, err := os.OpenFile("supported_mimes.md", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()

	nodes := root.flatten()
	header := fmt.Sprintf(`## %d Supported MIME types
This file is automatically generated when running tests. Do not edit manually.

Extension | MIME type
--------- | --------
`, len(nodes))

	if _, err := f.WriteString(header); err != nil {
		t.Fatal(err)
	}
	for _, n := range nodes {
		ext := n.extension
		if ext == "" {
			ext = "n/a"
		}
		str := fmt.Sprintf("**%s** | %s\n", ext, n.mime)
		if _, err := f.WriteString(str); err != nil {
			t.Fatal(err)
		}
	}
}

func BenchmarkMatchDetect(b *testing.B) {
	files := []string{"png.png", "jpg.jpg", "pdf.pdf", "zip.zip", "docx.docx", "doc.doc"}
	data, fLen := [][matchers.ReadLimit]byte{}, len(files)
	for _, f := range files {
		d := [matchers.ReadLimit]byte{}

		file, err := os.Open(filepath.Join(testDataDir, f))
		if err != nil {
			b.Fatal(err)
		}

		io.ReadFull(file, d[:])
		data = append(data, d)
	}

	b.ResetTimer()
	for n := 0; n < b.N; n++ {
		Detect(data[n%fLen][:])
	}
}
